# DUI+

![Python 3.6+](https://img.shields.io/badge/Python-3.6%2B-blue)
![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)

Toy reimplementation of some of the DUI/idials basic model as a flask-based
server application.

This is currently (for simplicity of matching models and to avoid too large a
knowledge gap) designed as a single-instance server application, and works with
the active model in memory rather than abstracted out to a database or similar.
This should be developed with the expectation that this might change in the
future.

## Getting started

1. Get [Poetry](https://github.com/python-poetry/poetry)
2. `git clone` this repository and `cd` to it
3. `poetry install`
4. `poetry run pytest`
5. `poetry run flask run`
6. `curl localhost:5000/command`

# API Documentation

## Endpoints Summary

Basic **plan** (read: not all implemented yet, this is a design)/mapping out of
potential endpoints. Since we only run one instance for now, we can have
everything be in the same namespace - (in future we could register this as a
sub-namespace potentially with auth, e.g. `/dui/:tree_id/....` There are only
two endpoints that alter data on the server. These are the `POST command/:name`
to run a new command, and the `DELETE /task/..` command to cancel a running
task. Multi-step operations (such as refine_lattice reindexing) can be
implemented by getting the results for a stage, and then submitting a further
"reindex" command, so don't need special endpoints.

| Endpoint                      | Purpose
| ----------------------------- | ----------------
| `GET /node`                   | Get the list of all nodes (to reconstruct a tree)
| `GET /node/:id`               | Get the node state for a single node
| `GET /node/:id/experiments`   | Get the experiment lists for a node
| `GET /node/:id/reflections`   | Get the reflection list for a node
| `GET /node/:id/log`           | Returns the streamlog file for a node
| `GET /node/:id/report`        | Returns the HTML dials report for a stage
| `GET /command`                | Get the list of commands that can be run
| `GET /command/:name`          | Get details about a command and it's options
| `POST /command/:name`         | Run a command. Pass arguments including parent node(s), run options
| `/tasks/....`                 | Task control interface. Get lists of running tasks, states and cancel

## Node

```
GET /node
```
Returns a description of the DUI Node Tree. This could be empty! The description is
a list of nodes, where each node is in the same form as the `/node/:id` endpoint.

```
GET /node/:id
```
Returns a single node of information. This is useful to refresh a node state or
validate that it matches the local expectation. An example response:
```
{
  "type": "Node",
  "id": "1",
  "uuid": "7feeec5cd99d464b8c841c668115be1f",
  "state": "CREATED",
  "parameters": { ... params ...},
  "task": "/task/<id>"
}
```
Common properties on a node are:

| Property  | Description
| --------- | ---------------
| `type`    | The kind of node, e.g. the sort of operation it represents
| `id`      | The DUI-tree ID, unique within a single tree
| `uuid`    | A UUID for this node. This allows nodes to be created by the client before being assigned an ID
| `state`   | The current node state. This can be `CREATED`, `RUNNING`, `FAILED` or `SUCCESS`
| `params`  | The parameters that were submitted to create this node
| `task`    | IF the node has an associated task then this is the task status endpoint

```
GET /node/:id/experiments
```
Retrieve the experiment lists dictionary for a node. This is currently a
literal dump of the `.expt` metadata file.

```
GET /node/:id/reflections
```
Get the reflection table. This will currently be a binary blob, of the `.refl`
file, like a file download, with the entire reflection table generated by a
stage.

```
GET /node/:id/report
```
Returns the HTML dials.report webpage for a node. If this doesn't yet exist,
it will be generated before return, unless the task is still in progress or
can't exist, in which case a `404 Not Found` status will be returned.

```
GET /node/:id/log[?offset=<int>]
```
Gets the log file for a node. Accepts optional argument `offset`, which will
cause a partial return of the logfile equivalent to seeking to that position
in the file first. This allows partial loading of very large log files.

## Command

```
GET /command
```
Returns a list of commands endpoints. This is of the form:
```
{
    "import": "/command/import".
    "find_spots": "/command/find_spots",
    ...
}
```
If you pass a node ID argument e.g. `GET /command?node=:node` then it will
only return a list of commands suitable for running after a particular node.
(note: Unsure if this is the best place to do this, or if this should be
handled by the server at all - but knowing the state of the physical tree and
what files are present probably useful for implementing this)

```
GET /command/:command
```
Retrieve information about a command. Example response:
```
Status: 200 OK
----
{
    "id": "find_spots",
    "endpoint": "/command/find_spots",
    "params": <Parameter List>
}
```
The params entry is special and possibly very large - this is effectively all
the PHIL options for the command (either as a PHIL scope or some internal
translation, yet to be decided), e.g. everything needed to know how to present
the command to the user. You could build the DUI Simple/Advanced tab using this.

*Note:* Command needn't map directly to dials commands. Likewise, the parameters
don't have to be command-line PHIL parameters. So e.g. there could be a command
`generate_and_apply_mask` that takes the new mask definition, and behind the
scenes, coordinates the generation and application of mask parameters. This
means that the server isn't just a thing wrapper over running DIALS commands.

```
POST /command/:name
```
Instruct the server to run a command. Responds with either `200 (OK)` for
immediately processed nodes, or `202 (Accepted)` for success with node
processing to be done asynchronously on the server. This will be return a
response of the form:
```
Status: 202 Accepted
---
{
    "id": "find_spots",
    "node": {
        "id": "<new_id>",
        ...node...,
        "task": "/task/<id>"
    }
}
```
The new node object will be returned, which will include a permanent tree ID.
If the node has an associated task job, then the node will have a `task` field
entry. Sending a `GET` request to the task status endpoint will return a status
object and a `202` response if the task is still in progress. If the task has
completed, then a `200` will be returned.

## Tasks

```
GET /task
```
Returns a list of tasks currently running. A task 
```
GET /task/<id>
```
Returns a status object for this task. The response code will be `202 (Accepted)`
if the task is still in progress, otherwise it will be `200 (OK)` if the task
has completed (even if the task failed or was cancelled). It's possible that
you might have a stale task link for an old task or instance of the task; the
status will return a `404 Not Found` response in these cases, at which point
you should refresh the task associations.

The form of the task information dictionary is:
```
{
    "id": "<task id>",
    "cancel": "<cancel endpoint>
}
```

Sending an HTTP `DELETE` request to the cancel endpoint will attempt to cancel
a running task. Either `200 OK` will be returned, or a `409 Conflict` if the
task has already completed.

It is intended that this endpoint will become a streaming endpoint to get JIT
updates for the status of a task; so that the client can be responsive. This is
not yet implemented.
